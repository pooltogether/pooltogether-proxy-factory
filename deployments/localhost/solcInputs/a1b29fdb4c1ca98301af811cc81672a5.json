{
  "language": "Solidity",
  "sources": {
    "contracts/GenericProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\";\n\n/// @title PoolTogether Generic Minimal ProxyFactory\n/// @notice EIP-1167 Minimal proxy factory pattern for creating proxy contracts\ncontract GenericProxyFactory{\n  \n  ///@notice Event fired when minimal proxy has been created\n  event ProxyCreated(address created, address implementation);\n\n  /// @notice Create a proxy contract for given instance\n  /// @param _instance Contract implementation which the created contract will point at\n  /// @param _data Data which is to be called after the proxy contract is created\n  function create(address _instance, bytes calldata _data) public returns (address) {\n    \n    address instanceCreated = ClonesUpgradeable.clone(_instance);\n    emit ProxyCreated(instanceCreated, _instance);\n\n    if(_data.length > 0) {\n      (bool success,) = instanceCreated.call(_data);\n      require(success, \"ProxyFactory/constructor-call-failed\");\n    }\n\n    return instanceCreated;\n  }\n\n  /// @notice Create a proxy contract with a deterministic address using create2\n  /// @param _instance Contract implementation which the created contract will point at\n  /// @param _salt Salt which is used as the create2 salt\n  /// @param _data Data which is to be called after the proxy contract is created\n  function create2(address _instance, bytes32 _salt, bytes calldata _data) public returns (address) {\n\n    address instanceCreated = ClonesUpgradeable.cloneDeterministic(_instance, _salt);\n    emit ProxyCreated(instanceCreated, _instance);\n\n    if(_data.length > 0) {\n      (bool success,) = instanceCreated.call(_data);\n      require(success, \"ProxyFactory/constructor-call-failed\");\n    }\n\n    return instanceCreated;\n  }\n\n  /// @notice Calculates what the proxy address would be when deterministically created\n  /// @param _master Contract implementation which the created contract will point at\n  /// @param _salt Salt which would be used as the create2 salt\n  function predictDeterministicAddress(address _master, bytes32 _salt) public view returns (address) {\n    return ClonesUpgradeable.predictDeterministicAddress(_master, _salt, address(this));\n  }\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary ClonesUpgradeable {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address master) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create(0, ptr, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `master`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `master` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address master, bytes32 salt) internal returns (address instance) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            instance := create2(0, ptr, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt, address deployer) internal pure returns (address predicted) {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(ptr, 0x14), shl(0x60, master))\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\n            mstore(add(ptr, 0x4c), salt)\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\n            predicted := keccak256(add(ptr, 0x37), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(address master, bytes32 salt) internal view returns (address predicted) {\n        return predictDeterministicAddress(master, salt, address(this));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "istanbul",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}